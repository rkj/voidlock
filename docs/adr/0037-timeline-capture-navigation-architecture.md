# ADR 0037: Timeline Capture Navigation Architecture

## Status

Proposed

## Date

2026-02-08

## Problem Statement

The timeline pipeline must produce reliable, historically accurate screenshots across hundreds of commits with significant UI drift. Current behavior is unstable for three reasons:

1. Navigation plans generated by the agent can be semantically wrong for a commit (for example, navigating to campaign while labeled as mission).
2. Runtime state leaks (LocalStorage/session state) can alter startup screens and invalidate click paths.
3. Capture quality gates can produce false positives (wrong screen accepted) or false negatives (valid mission rejected as dark).

The key product requirement is strict:
- For every buildable commit, the pipeline must capture a valid mission screenshot.
- Missing mission is only acceptable for explicitly allowlisted broken commits.

## Decision (High-Level Approach)

Adopt a **Plan-Compile-Execute-Verify** architecture with strict separation of concerns:

1. **Agent is used only for constrained planning** on topology anchor commits.
2. **Deterministic executor performs all screenshots** for all commits.
3. **Verification is mandatory** and blocks promotion of bad plans.
4. **Mission is hard-required by default** (except explicit allowlist entries).

This is not “deterministic between commits”; it is deterministic per commit once a compiled plan is selected for that commit.

## Detailed Design

### Step 1: Manifest

Purpose:
- Enumerate ordered commits to process.

Output:
- `timeline/manifest.json`

Guarantee:
- Single source of truth for commit order and dates.

### Step 2: Navigation Analysis

Purpose:
- Extract stable UI hints (`btn-*`, `screen-*`, targets) from each commit.

Output:
- `timeline/navigation_map.json`

Guarantee:
- Structural metadata for planning and era segmentation.

### Step 3: Topology Segmentation

Purpose:
- Group commits into eras where UI topology is similar.

Output:
- `timeline/screen_topology_changes.json`

Guarantee:
- Agent planning runs only on anchor eras; unchanged eras can reuse prior plans.

### Step 4: Constrained Agent Planning (Anchor Eras)

Purpose:
- Generate candidate playbooks for anchor commits/eras.

Hard constraints:
- Browser-first behavior.
- No repository/source inspection.
- No DOM/style force-show operations.
- Allowed actions: click/text/wait/noop only.
- Risky actions forbidden (`reset`, `abort`, `give up`, `abandon`, `surrender`).

Output:
- `timeline/navigation_playbooks.json` (era plans)

Policy:
- If era flow signature is unchanged, reuse prior era playbook and skip new agent run.

### Step 5: Plan Compilation

Purpose:
- Expand era playbooks into exact per-commit plans.

Output:
- `timeline/commit_playbooks.jsonl`

Guarantee:
- One deterministic action set per commit at execution time.

### Step 6: Deterministic Capture Execution

Purpose:
- For each commit: checkout, start server, reset browser storage, run flows, capture screenshots.

Execution protocol per screen:
1. Navigate to `/`.
2. Clear origin storage before flow.
3. Execute commit playbook steps (scroll into view before clicks).
4. Capture full viewport screenshot.

Mission policy:
- Mission capture is required by default.
- If mission is missing, fail commit capture.
- Exception only for SHA prefixes listed in `timeline/mission_allowlist.txt`.

Output:
- `screenshots/<timestamp>_<screen>_<sha>.png`

### Step 7: Screen Verification

Purpose:
- Validate semantic correctness of captured screens before frame composition.

Mission validation:
- Must satisfy mission UI predicates.
- Must fail if campaign-shell predicates are present (`sector map`, `scrap/intel`, `barracks`, etc).

Campaign/config/main-menu validation:
- Must satisfy target-specific visible token checks.

Failure behavior:
- Commit marked failed/skipped with explicit reason.
- Pipeline aborts after configured consecutive failures.

### Step 8: Frame Analysis and Render

Purpose:
- Deduplicate, compose adaptive layouts, render MP4.

Outputs:
- `timeline/frame_index.json`
- `timeline/voidlock_timeline_full.mp4`

## Single-Agent vs Multi-Agent Decision

Decision:
- Use **single agent for planning only** (per anchor era), not for screenshot execution.

Rationale:
- Screenshot execution must be deterministic, replayable, and fast across many commits.
- Agent-driven execution for every commit is expensive and difficult to reproduce exactly.
- Deterministic executor + strict verifier provides stable outputs and clear failure modes.

Future extension:
- Optional second agent can review failed commits and propose plan patches, but execution remains deterministic.

## Operational Rules

1. Mission screenshots are mandatory unless allowlisted.
2. Risky actions are blocked globally in executor.
3. Browser storage is cleared before each flow.
4. Any semantic mismatch (for example campaign accepted as mission) is treated as a pipeline defect and must be fixed in verifier/executor logic.

## Consequences

Positive:
- Higher reliability and reproducibility.
- Clear ownership boundaries (agent plans, executor runs, verifier enforces correctness).
- Reduced token/runtime by reusing unchanged era playbooks.

Negative:
- Additional validator complexity.
- Requires maintaining mission allowlist for truly broken commits.

## Migration Plan

1. Keep existing artifacts.
2. Regenerate `navigation_map` and `topology`.
3. Regenerate playbooks with constrained agent.
4. Rebuild `commit_playbooks.jsonl`.
5. Re-run capture with mission-required policy.
6. Add only truly broken SHAs to allowlist.
7. Re-run frame analysis and render.

